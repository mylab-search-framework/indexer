# MyLab.Search.Indexer

[![Docker image](https://img.shields.io/static/v1?label=docker&style=flat&logo=docker&message=v1.x.x&color=blue)](https://github.com/mylab-search-fx/indexer/pkgs/container/indexer)

Индексирует данные из базы данных и/или `RabbitMQ` в `ElasticSearch`.

## Обзор

![](./doс/mylab-search-index.png)

На схеме выше показаны все участники процесса индексации и их связи.

Процесс индексации определяет следующие особенности:

* данные могут быть получены из очереди (`RabbitMQ`) и/или из БД в зависимости от настроек;
* база данных является приоритетным источником, т.е. если данные об индексируемой сущности приходят через очередь, то они перезапишутся данными из БД в ближайшей итерации по расписанию;
* при совместном использовании, очерди и БД, назначение очереди - максимально быстро доставить данные для индексирования.

## Индексация через очередь

При передаче данных через очередь, сущности передаются по одному в формате `JSON`. Не в зависимости от того, изменена ли сущетсвующая сущность или создаётся новая, передаваться в сообщении должны актуальные данные в том виде, в каком они будут индексироваться. В случае, если сущность новая, то запись о ней появится в `ElasticSearch`. Если сущность была изменена и её индесированная копия уже есть в `ElasticSearch`, то данные будут заменены. Сопоставление переданной сущности и индексированной копии происходит по полю, указанному в настройках `Indexer` как поле-идентификатор. 

Ниже приведён пример отправки тестовой сущности. В настройках `Indexer` поле-идентификатор `Id`:

```C#
public class SearchTestEntity
{
    public long Id { get; set; }
    public string Value { get; set; }
}
```

Тело сообщения #1 в очереди:

```json
{"Id":2,"Value":"foo"}
```

Результат поиска #1 индексированной сущности (лишнее обрезано):

```json
{ "_source": { "Id": 2, "Value": "foo" } }
```

Тело сообщения #2 в очереди:

```json
{"Id":2,"Value":"bar"}
```

Результат поиска #2 индексированной сущности (лишнее обрезано):

```json
{ "_source": { "Id": 2, "Value": "bar" } }
```

## Индексация через БД

Выборка даных для индексации осуществляется в соответствии с настройками и "отступом" последней выборки - `seed`. В зависимости от выбранной стратегии выборки, seed может принимать целочисленное значение или дату и время. В конце каждой итерации новый `seed` сохраняется в локальный файл. В начале очередной итерации - загружается. Если это первая итерации или файл не найден, то используется минимальное значение соответствующего типа.

Индексация через базу данных осуществляется по вызову планировщика и подразумевает следующий алгоритм:

* определяется `seed`(состояние), с которого начнётся выборка (загружается ранее сохранённый или минимальное значение);
* загрузка и индексирование данных по частям (paging) или целиком в зависимости от настроек:
  * происходит выборка данных;
  * данные оптравляются в `ElasticSearch` для индексации;
* определяется новый `seed` и сохраняется в файл.

Строка запроса в БД указывается в конфигурации и представляет из себя `SQL` запрос, в котором доступны следующие переменные:

- `seed` - "отсутп" очередного запроса;
- `offset` - сдвиг выборки 
- `limit` - предел выборки

Для индексации только новых данных необходимо применить в запросе переменную `seed` в соответствии с выбранной стратегией. Для реализации порциональной выборки и иендекцации в рамках одной итерации, необходимо в запросе испольщовать параметры `offset` и `limit`. 

Ниже приведён пример использования всех параметров в контексте БД `sqlite`:

```sql
select * from foo_table where LastModified > @seed limit @limit offset @offset
```

### Стратегия `Add`

Испольуется в случае, если данные только добавляются. Например - протокол действий. 

При этой стратегии:

* идентификатор сущности должен принимать целочисленные значения;
* очередная сущность должна иметь идентификатор с большим значением, чем предыдущая;
* `seed` будет иметь самое большое значение идентификатора сущности из последней итерации;
* нужно использовать `seed` в запросе для сравнения с полем-идентификатором.

Пример `sql` запроса:

```sql
select * from foo_table where Id > @seed
```

### Стратегия `Update`

Испольуется в случае, если данные могут добавляться и имзенять. 

При этой стратегии:

* идентификатор сущности может быть любого типа;
* должно быть поле типа дата+время (например, `LastModified`), которе будет обновляться при обновлении сущности;
* `seed` будет иметь самое большое значение даты+времени "`LastModified`" из последней итерации;
* нужно использовать `seed` в запросе для сравнения с полем "`LastModified`".

Пример `sql` запроса:

```sql
select * from foo_table where LastModified > @seed
```

## Удаление из индекса

Данное решение не реализует удаление индексированных данных. Например, при удалении сущности из БД. 

Подразумеваются следующие варианты решения:

* самостоятельно реализовать удаление идексируемых сущностей;
* не удалять сущности, а помечать их как удалённые, что с точки зрения `Indexer` является изменением сущности.

## Конфигурирование

## Развёртывание
